using Woodcraft.Core.Interfaces;

namespace Woodcraft.Desktop.Services;

/// <summary>
/// Service for exporting project data.
/// </summary>
public class ExportService : IExportService
{
    private readonly ICadService _cadService;
    private readonly IProjectService _projectService;

    public IReadOnlyList<ExportFormat> SupportedFormats { get; } =
    [
        new ExportFormat { Name = "STEP", Extension = ".step", Description = "Standard for Exchange of Product Data", Category = "3D" },
        new ExportFormat { Name = "STL", Extension = ".stl", Description = "Stereolithography mesh", Category = "3D" },
        new ExportFormat { Name = "DXF", Extension = ".dxf", Description = "Drawing Exchange Format", Category = "2D" },
        new ExportFormat { Name = "SVG", Extension = ".svg", Description = "Scalable Vector Graphics", Category = "2D" },
        new ExportFormat { Name = "CSV", Extension = ".csv", Description = "Comma Separated Values", Category = "Data" },
        new ExportFormat { Name = "Markdown", Extension = ".md", Description = "Markdown text", Category = "Document" },
    ];

    public ExportService(ICadService cadService, IProjectService projectService)
    {
        _cadService = cadService;
        _projectService = projectService;
    }

    public async Task<string> ExportCutListPdfAsync(string outputPath, CancellationToken cancellationToken = default)
    {
        var project = _projectService.CurrentProject;
        if (project == null)
            throw new InvalidOperationException("No project open");

        // Export as text-based cut list summary (PDF requires external library)
        var lines = new List<string>
        {
            $"Cut List - {project.Name}",
            new string('=', 60),
            "",
            $"{"Part",-20} {"Length",-10} {"Width",-10} {"Thickness",-12} {"Qty",-6} {"Material",-15}",
            new string('-', 73),
        };

        foreach (var part in project.Parts)
        {
            lines.Add($"{part.Id,-20} {part.Dimensions.Length,-10:F2} {part.Dimensions.Width,-10:F2} {part.Dimensions.Thickness,-12:F3} {part.Quantity,-6} {part.Material ?? "N/A",-15}");
        }

        lines.Add(new string('-', 73));
        lines.Add($"Total parts: {project.Parts.Count}");
        lines.Add($"Total board feet: {project.TotalBoardFeet:F2}");

        // Write as .txt since we don't have a PDF library
        var txtPath = Path.ChangeExtension(outputPath, ".txt");
        await File.WriteAllLinesAsync(txtPath, lines, cancellationToken);
        return txtPath;
    }

    public async Task<string> ExportBOMCsvAsync(string outputPath, CancellationToken cancellationToken = default)
    {
        var project = _projectService.CurrentProject;
        if (project == null)
            throw new InvalidOperationException("No project open");

        var lines = new List<string>
        {
            "Part ID,Type,Length,Width,Thickness,Quantity,Material,Notes"
        };

        foreach (var part in project.Parts)
        {
            lines.Add($"\"{part.Id}\",\"{part.PartType}\",{part.Dimensions.Length},{part.Dimensions.Width},{part.Dimensions.Thickness},{part.Quantity},\"{part.Material}\",\"{part.Notes}\"");
        }

        await File.WriteAllLinesAsync(outputPath, lines, cancellationToken);
        return outputPath;
    }

    public async Task<string> ExportAssemblyGuideAsync(string outputPath, CancellationToken cancellationToken = default)
    {
        var project = _projectService.CurrentProject;
        if (project == null)
            throw new InvalidOperationException("No project open");

        var lines = new List<string>
        {
            $"# Assembly Guide: {project.Name}",
            "",
            $"> Generated by Woodcraft",
            "",
            "## Parts List",
            "",
            "| Part | Dimensions | Qty | Material |",
            "|------|-----------|-----|----------|",
        };

        foreach (var part in project.Parts)
        {
            lines.Add($"| {part.Id} | {part.Dimensions.Length}\" x {part.Dimensions.Width}\" x {part.Dimensions.Thickness}\" | {part.Quantity} | {part.Material ?? "N/A"} |");
        }

        if (project.Hardware.Count > 0)
        {
            lines.Add("");
            lines.Add("## Hardware");
            lines.Add("");
            lines.Add("| Item | Qty | Notes |");
            lines.Add("|------|-----|-------|");
            foreach (var hw in project.Hardware)
            {
                lines.Add($"| {hw.Name} | {hw.Quantity} | {hw.Description} |");
            }
        }

        lines.Add("");
        lines.Add("## Notes");
        lines.Add("");
        lines.Add(project.Notes ?? "No additional notes.");

        await File.WriteAllLinesAsync(outputPath, lines, cancellationToken);
        return outputPath;
    }

    public async Task<string> ExportStepAsync(string outputPath, string? partId = null, CancellationToken cancellationToken = default)
    {
        var path = await _cadService.ExportStepAsync(partId, cancellationToken);
        if (!string.IsNullOrEmpty(outputPath) && File.Exists(path))
        {
            File.Copy(path, outputPath, overwrite: true);
            return outputPath;
        }
        return path;
    }

    public async Task<string> ExportStlAsync(string outputPath, string? partId = null, CancellationToken cancellationToken = default)
    {
        var path = await _cadService.ExportStlAsync(partId, cancellationToken);
        if (!string.IsNullOrEmpty(outputPath) && File.Exists(path))
        {
            File.Copy(path, outputPath, overwrite: true);
            return outputPath;
        }
        return path;
    }

    public async Task<string> ExportDrawingDxfAsync(string outputPath, string partId, CancellationToken cancellationToken = default)
    {
        var path = await _cadService.GenerateDrawingAsync(partId, ["top", "front", "side"], "dxf", cancellationToken);
        if (!string.IsNullOrEmpty(outputPath) && File.Exists(path))
        {
            File.Copy(path, outputPath, overwrite: true);
            return outputPath;
        }
        return path;
    }
}
